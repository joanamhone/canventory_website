// src/context/AppContext.tsx
import React, { createContext, useContext, useState, ReactNode, useEffect, useCallback } from 'react';
import { Patient, Treatment, TreatmentMedication, TreatmentService, SupabaseTreatment } from '../types/patient';
import { InventoryItem, InventoryTransaction, StockAlert, InventoryTransactionType, InventoryReferenceType, InventoryItemCategory } from '../types/inventory';
import { Payment, PaymentAlert, PaymentSettings } from '../types/payment';
import { ClinicSettings, InventorySettings } from '../types/settings';
import toast from 'react-hot-toast';
import { addDays, isPast } from 'date-fns';
import { supabase } from '../lib/supabaseClient';
import { User, Session } from '@supabase/supabase-js';

interface AppContextType {
  // Existing states
  patients: Patient[];
  treatments: Treatment[];
  inventoryItems: InventoryItem[];
  inventoryTransactions: InventoryTransaction[];
  stockAlerts: StockAlert[];
  payments: Payment[];
  paymentAlerts: PaymentAlert[];
  paymentSettings: PaymentSettings;
  clinicSettings: ClinicSettings | null;
  inventorySettings: InventorySettings;

  // New auth states
  user: User | null;
  session: Session | null;
  authLoading: boolean;

  // Existing actions
  // userId is now REQUIRED as input for addPatient
  addPatient: (patient: Omit<Patient, 'id' | 'createdAt' | 'updatedAt' | 'hasOutstandingBalance' | 'totalOutstanding'> & { userId: string }) => Promise<void>;
  updatePatient: (id: string, patientData: Partial<Patient>) => Promise<void>;
  deletePatient: (id: string) => Promise<void>;

  // userId is now REQUIRED as input for addTreatment
  // totalCost is now omitted as it's calculated internally
  addTreatment: (treatment: Omit<Treatment, 'id' | 'createdAt' | 'updatedAt' | 'amountPaid' | 'paymentStatus' | 'totalCost'> & { userId: string }) => Promise<void>;
  updateTreatment: (id: string, treatmentData: Partial<Treatment>) => Promise<void>;

  addInventoryItem: (item: Omit<InventoryItem, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
  updateInventoryItem: (id: string, itemData: Partial<InventoryItem>) => Promise<void>;
  deleteInventoryItem: (id: string) => Promise<void>;

  // 'balance' is calculated internally, 'id' and 'createdAt' are generated by Supabase.
  // 'createdBy' is expected as an input.
  // Explicitly allow referenceId to be string | null to match the type definition
  addInventoryTransaction: (transaction: Omit<InventoryTransaction, 'id' | 'createdAt' | 'balance'>) => Promise<void>;

  addPayment: (payment: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
  updatePaymentSettings: (settings: Partial<PaymentSettings>) => Promise<void>;
  updateClinicSettings: (settings: Partial<ClinicSettings>) => Promise<void>;
  updateInventorySettings: (settings: Partial<InventorySettings>) => Promise<void>;

  markAlertAsRead: (id: string, type: 'stock' | 'payment') => Promise<void>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

// Define a type for the object to be inserted into inventory_transactions table
// This type includes 'balance' and 'created_at' which are generated/calculated within the function
// It uses snake_case for Supabase column names
interface SupabaseInventoryTransactionInsert {
  inventory_item_id: string;
  type: InventoryTransactionType;
  quantity: number;
  balance: number;
  reason: string;
  reference_id: string | null; // Matches Supabase column type
  reference_type: InventoryReferenceType;
  created_by: string;
  created_at: Date;
}

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // States for data
  const [patients, setPatients] = useState<Patient[]>([]);
  const [treatments, setTreatments] = useState<Treatment[]>([]);
  const [inventoryItems, setInventoryItems] = useState<InventoryItem[]>([]);
  const [inventoryTransactions, setInventoryTransactions] = useState<InventoryTransaction[]>([]);
  const [stockAlerts, setStockAlerts] = useState<StockAlert[]>([]);
  const [payments, setPayments] = useState<Payment[]>([]);
  const [paymentAlerts, setPaymentAlerts] = useState<PaymentAlert[]>([]);
  const [paymentSettings, setPaymentSettings] = useState<PaymentSettings>({
    gracePeriod: 30,
    reminderIntervals: [7, 14, 30],
    autoNotify: true,
  });
  const [clinicSettings, setClinicSettings] = useState<ClinicSettings | null>(null);
  const [inventorySettings, setInventorySettings] = useState<InventorySettings>({
    id: '1',
    lowStockThreshold: 20,
    enableAutoReorder: false,
    autoReorderThreshold: 10,
    createdAt: new Date(),
    updatedAt: new Date(),
  });

  // New states for authentication
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [authLoading, setAuthLoading] = useState(true);

  // Helper function for robust number conversion
  const toSafeNumber = (value: any): number => {
    const num = Number(value);
    return isNaN(num) ? 0 : num;
  };

  // --- Auth State Management ---
  useEffect(() => {
    setAuthLoading(true);

    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user || null);
      setAuthLoading(false);
    }).catch((error) => {
      console.error("Error getting session:", error);
      setAuthLoading(false);
    });

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session);
        setUser(session?.user || null);
        if (_event === 'INITIAL_SESSION' || _event === 'SIGNED_IN' || _event === 'SIGNED_OUT') {
          setAuthLoading(false);
        }
        console.log("Auth State Changed:", _event, session?.user?.id);
      }
    );

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  // --- Data Fetching Logic (Memoized with useCallback) ---
  const fetchData = useCallback(async () => {
    if (authLoading || !user || !session) {
      setPatients([]);
      setTreatments([]);
      setInventoryItems([]);
      setInventoryTransactions([]);
      setStockAlerts([]);
      setPayments([]);
      setPaymentAlerts([]);
      setPaymentSettings({
        gracePeriod: 30,
        reminderIntervals: [7, 14, 30],
        autoNotify: true,
      });
      setClinicSettings(null);
      setInventorySettings({
        id: '1',
        lowStockThreshold: 20,
        enableAutoReorder: false,
        autoReorderThreshold: 10,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
      return;
    }

    try {
      // Patients
      const { data: patientsData, error: patientsError } = await supabase
        .from<'patients', Patient>('patients')
        .select('*');
      if (patientsError) throw patientsError;
      setPatients(patientsData || []);

      // Treatments
      const { data: rawTreatmentsData, error: treatmentsError } = await supabase
        .from('treatments')
        .select('*');
      if (treatmentsError) throw treatmentsError;
      
      // NEW DEBUG LOG: Raw data from Supabase before conversion
     // console.log('Raw Treatments Data from Supabase:', rawTreatmentsData);

      const parsedTreatmentsData: Treatment[] = rawTreatmentsData?.map((t: SupabaseTreatment) => {
        // Parse medications and services if they are strings
        const medicationsArray = typeof t.medications === 'string' ? JSON.parse(t.medications) : t.medications;
        const servicesArray = typeof t.services === 'string' ? JSON.parse(t.services) : t.services;

        return {
          id: t.id,
          patientId: t.patient_id,
          diagnosis: t.diagnosis,
          notes: t.notes || undefined,
          medications: (Array.isArray(medicationsArray) ? medicationsArray : []).map((med: any) => ({
            id: med.id,
            inventoryItemId: med.inventoryItemId,
            name: med.name,
            quantity: toSafeNumber(med.quantity),
            dosage: med.dosage,
            unitCost: toSafeNumber(med.unitCost),
            totalCost: toSafeNumber(med.totalCost),
          })) as TreatmentMedication[],
          services: (Array.isArray(servicesArray) ? servicesArray : []).map((service: any) => ({
            id: service.id,
            name: service.name,
            description: service.description,
            cost: toSafeNumber(service.cost),
          })) as TreatmentService[],
          date: t.date ? new Date(t.date) : new Date(),
          totalCost: toSafeNumber(t.total_cost),
          amountPaid: toSafeNumber(t.amount_paid),
          paymentStatus: t.payment_status,
          dueDate: t.due_date ? new Date(t.due_date) : undefined,
          createdAt: t.created_at ? new Date(t.created_at) : new Date(),
          updatedAt: t.updated_at ? new Date(t.updated_at) : new Date(),
          userId: t.user_id,
        };
      }) || [];

      // ADDED DEBUG LOG HERE
     // console.log('Fetched Treatments (after conversion):', parsedTreatmentsData); 

      setTreatments(parsedTreatmentsData);

      // Inventory Items
      const { data: inventoryData, error: inventoryError } = await supabase
        .from<'inventory_items', InventoryItem>('inventory_items')
        .select('*');
      if (inventoryError) throw inventoryError;

      const parsedInventoryData = inventoryData?.map(item => ({
        id: item.id,
        name: item.name,
        category: item.category as InventoryItemCategory, // Cast to InventoryItemCategory
        supplier: item.supplier,
        currentStock: toSafeNumber(item.current_stock),
        unit: item.unit,
        unitCost: toSafeNumber(item.unit_cost),
        reorderLevel: toSafeNumber(item.reorder_level),
        reorderQuantity: toSafeNumber(item.reorder_quantity),
        notes: item.notes,
        createdAt: item.created_at ? new Date(item.created_at) : new Date(),
        updatedAt: item.updated_at ? new Date(item.updated_at) : new Date(),
      })) || [];
      setInventoryItems(parsedInventoryData);

      // Inventory Transactions
      const { data: transactionsData, error: transactionsError } = await supabase
        .from<'inventory_transactions', InventoryTransaction>('inventory_transactions')
        .select('*');
      if (transactionsError) throw transactionsError;
      const parsedTransactionsData = transactionsData?.map(transaction => ({
        id: transaction.id,
        inventoryItemId: transaction.inventory_item_id,
        type: transaction.type as InventoryTransactionType,
        quantity: transaction.quantity,
        balance: transaction.balance,
        reason: transaction.reason,
        referenceId: transaction.reference_id,
        referenceType: transaction.reference_type as InventoryReferenceType,
        createdBy: transaction.created_by,
        createdAt: transaction.created_at ? new Date(transaction.created_at) : new Date(),
      })) || [];
      setInventoryTransactions(parsedTransactionsData);

      // Stock Alerts
      const { data: stockAlertsData, error: stockAlertsError } = await supabase
        .from<'stock_alerts', StockAlert>('stock_alerts')
        .select('*');
      if (stockAlertsError) throw stockAlertsError;
      const parsedStockAlertsData = stockAlertsData?.map(alert => ({
        id: alert.id,
        inventoryItemId: alert.inventory_item_id,
        type: alert.type,
        message: alert.message,
        isRead: alert.is_read,
        createdAt: alert.created_at ? new Date(alert.created_at) : new Date(),
      })) || [];
      setStockAlerts(parsedStockAlertsData);

      // Payments
      const { data: paymentsData, error: paymentsError } = await supabase
        .from<'payments', Payment>('payments')
        .select('*');
      if (paymentsError) throw paymentsError;
      const parsedPaymentsData: Payment[] = paymentsData?.map(payment => ({
        id: payment.id,
        treatmentId: payment.treatment_id,
        patientId: payment.patient_id,
        amount: payment.amount,
        paymentDate: payment.payment_date ? new Date(payment.payment_date) : new Date(),
        method: payment.method,
        status: payment.status,
        notes: payment.notes,
        createdAt: payment.created_at ? new Date(payment.created_at) : new Date(),
        updatedAt: payment.updated_at ? new Date(payment.updated_at) : new Date(),
      })) || [];
      setPayments(parsedPaymentsData);

      // Payment Settings (assume single row settings)
      const { data: paymentSettingsData, error: paymentSettingsError } = await supabase
        .from<'payment_settings', PaymentSettings>('payment_settings')
        .select('*')
        .limit(1)
        .single();
      if (!paymentSettingsError && paymentSettingsData) {
        setPaymentSettings({
          gracePeriod: paymentSettingsData.grace_period,
          reminderIntervals: paymentSettingsData.reminder_intervals,
          autoNotify: paymentSettingsData.auto_notify,
        });
      }

      // Clinic Settings (assume single row settings)
      const { data: clinicSettingsData, error: clinicSettingsError } = await supabase
        .from<'clinic_settings', ClinicSettings>('clinic_settings')
        .select('*')
        .limit(1)
        .single();
      if (!clinicSettingsError && clinicSettingsData) {
        setClinicSettings({
          id: clinicSettingsData.id,
          clinicName: clinicSettingsData.clinic_name,
          address: clinicSettingsData.address,
          phone: clinicSettingsData.phone,
          email: clinicSettingsData.email,
          logoUrl: clinicSettingsData.logo_url,
          createdAt: clinicSettingsData.created_at ? new Date(clinicSettingsData.created_at) : new Date(),
          updatedAt: clinicSettingsData.updated_at ? new Date(clinicSettingsData.updated_at) : new Date(),
        });
      }

      // Inventory Settings (assume single row settings)
      const { data: inventorySettingsData, error: inventorySettingsError } = await supabase
        .from<'inventory_settings', InventorySettings>('inventory_settings')
        .select('*')
        .limit(1)
        .single();
      if (!inventorySettingsError && inventorySettingsData) {
        setInventorySettings({
          id: inventorySettingsData.id,
          lowStockThreshold: inventorySettingsData.low_stock_threshold,
          enableAutoReorder: inventorySettingsData.enable_auto_reorder,
          autoReorderThreshold: inventorySettingsData.auto_reorder_threshold,
          createdAt: inventorySettingsData.created_at ? new Date(inventorySettingsData.created_at) : new Date(),
          updatedAt: inventorySettingsData.updated_at ? new Date(inventorySettingsData.updated_at) : new Date(),
        });
      }

    } catch (error) {
      toast.error('Failed to load data from database');
      console.error(error);
    }
  }, [user, session, authLoading]);

  // --- Trigger Data Fetching when Auth State Changes ---
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Function to check overdue payments & add alerts to DB if missing
  useEffect(() => {
    async function checkOverduePayments() {
      if (!user || !session || treatments.length === 0 || authLoading) {
        return;
      }
      for (const treatment of treatments) {
        if (treatment.paymentStatus !== 'paid' && treatment.dueDate) {
          const isOverdue = isPast(new Date(treatment.dueDate));
          if (isOverdue) {
            const existingAlert = paymentAlerts.find(
              alert => alert.treatmentId === treatment.id && !alert.isRead
            );
            if (!existingAlert) {
              const newAlert = {
                patient_id: treatment.patientId,
                treatment_id: treatment.id,
                due_amount: treatment.totalCost - treatment.amountPaid,
                due_date: treatment.dueDate,
                status: 'overdue',
                is_read: false,
                created_at: new Date(),
              };
              const { data, error } = await supabase.from('payment_alerts').insert(newAlert).select().single();
              if (error) {
                console.error('Failed to add payment alert:', error);
              } else if (data) {
                const addedAlert: PaymentAlert = {
                  id: data.id,
                  patientId: data.patient_id,
                  treatmentId: data.treatment_id,
                  dueAmount: data.due_amount,
                  dueDate: data.due_date ? new Date(data.due_date) : new Date(),
                  status: data.status,
                  isRead: data.is_read,
                  createdAt: data.created_at ? new Date(data.created_at) : new Date(),
                };
                setPaymentAlerts(prev => [...prev, addedAlert]);
                const patient = patients.find(p => p.id === treatment.patientId);
                if (patient) {
                  toast.error(`Payment overdue for patient: ${patient.name}`, {
                    duration: 5000,
                    position: 'top-right',
                  });
                }
              }
            }
          }
        }
      }
    }

    if (user && session && treatments.length > 0 && !authLoading) {
      checkOverduePayments();
      const interval = setInterval(checkOverduePayments, 24 * 60 * 60 * 1000);
      return () => clearInterval(interval);
    }
  }, [treatments, paymentAlerts, patients, paymentSettings.gracePeriod, user, session, authLoading]);

  // Check low stock alerts and add to DB if missing
  useEffect(() => {
    async function checkLowStock() {
      if (!user || !session || inventoryItems.length === 0 || authLoading) {
        return;
      }
      for (const item of inventoryItems) {
        if (item.currentStock <= item.reorderLevel) {
          const existingAlert = stockAlerts.find(
            alert => alert.inventoryItemId === item.id && alert.type === 'low' && !alert.isRead
          );
          if (!existingAlert) {
            const newAlert = {
              inventory_item_id: item.id,
              type: 'low',
              message: `${item.name} is low in stock (${item.currentStock} ${item.unit} remaining)`,
              is_read: false,
              created_at: new Date(),
            };
            const { data, error } = await supabase.from('stock_alerts').insert(newAlert).select().single();
            if (error) {
              console.error('Failed to add stock alert:', error);
            } else if (data) {
              const addedAlert: StockAlert = {
                id: data.id,
                inventoryItemId: data.inventory_item_id,
                type: data.type,
                message: data.message,
                isRead: data.is_read,
                createdAt: data.created_at ? new Date(data.created_at) : new Date(),
              };
              setStockAlerts(prev => [...prev, addedAlert]);
              toast.error(`Low stock alert: ${item.name}`, {
                duration: 5000,
                position: 'top-right',
              });
            }
          }
        }
      }
    }

    if (user && session && inventoryItems.length > 0 && !authLoading) {
      checkLowStock();
    }
  }, [inventoryItems, stockAlerts, user, session, authLoading]);

  // PATIENT ACTIONS
  const addPatient = async (
    patientData: Omit<Patient, 'id' | 'createdAt' | 'updatedAt' | 'hasOutstandingBalance' | 'totalOutstanding'> & { userId: string }
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add patient.');
        return;
      }
      const newPatient = {
        name: patientData.name,
        age: patientData.age,
        gender: patientData.gender,
        residence: patientData.residence,
        phone: patientData.phone || null, // Ensure null for optional string
        email: patientData.email || null, // Ensure null for optional string
        address: patientData.address || null, // Ensure null for optional string
        has_outstanding_balance: false, // This is correct (snake_case)
        total_outstanding: 0,           // This is correct (snake_case)
        created_at: new Date(),
        updated_at: new Date(),
        user_id: patientData.userId,
      };
      const { error } = await supabase.from('patients').insert([newPatient]).select().single();
      if (error) throw error;
      // setPatients(prev => [...prev, data]); // Removed direct state update
      toast.success(`Patient ${patientData.name} added successfully`);
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to add patient');
      console.error(error);
    }
  };

  const updatePatient = async (id: string, patientData: Partial<Patient>) => {
    const updatedPatientData: any = { updated_at: new Date() };
    if (patientData.hasOutstandingBalance !== undefined) updatedPatientData.has_outstanding_balance = patientData.hasOutstandingBalance;
    if (patientData.totalOutstanding !== undefined) updatedPatientData.total_outstanding = patientData.totalOutstanding;
    if (patientData.name !== undefined) updatedPatientData.name = patientData.name;
    if (patientData.email !== undefined) updatedPatientData.email = patientData.email;
    if (patientData.phone !== undefined) updatedPatientData.phone = patientData.phone;
    if (patientData.address !== undefined) updatedPatientData.address = patientData.address;

    try {
      const { error } = await supabase
        .from('patients')
        .update(updatedPatientData)
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      // setPatients(prev => prev.map(p => (p.id === id ? data : p))); // Removed direct state update
      toast.success('Patient updated successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to update patient');
      console.error(error);
    }
  };

  const deletePatient = async (id: string) => {
    try {
      const { error } = await supabase.from('patients').delete().eq('id', id);
      if (error) throw error;
      // setPatients(prev => prev.filter(p => p.id !== id)); // Removed direct state update
      toast.success('Patient deleted successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to delete patient');
      console.error(error);
    }
  }
  // TREATMENT ACTIONS
  const addTreatment = async (
    treatmentData: Omit<Treatment, 'id' | 'createdAt' | 'updatedAt' | 'amountPaid' | 'paymentStatus' | 'totalCost'> & { userId: string }
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add treatment.');
        return;
      }

      // Calculate totalCost dynamically based on medications and services
      const calculatedTotalCost =
        (treatmentData.medications?.reduce((sum, med) => sum + (med.totalCost ?? 0), 0) || 0) +
        (treatmentData.services?.reduce((sum, service) => sum + (service.cost ?? 0), 0) || 0);

      const newTreatment = {
        diagnosis: treatmentData.diagnosis,
        notes: treatmentData.notes,
        medications: treatmentData.medications, // medications is already an array of TreatmentMedication
        services: treatmentData.services,     // services is already an array of TreatmentService
        date: treatmentData.date,
        total_cost: calculatedTotalCost, // Use the dynamically calculated totalCost
        amount_paid: 0,
        payment_status: 'pending' as const,
        due_date: addDays(new Date(), paymentSettings.gracePeriod),
        created_at: new Date(),
        updated_at: new Date(),
        patient_id: treatmentData.patientId,
        user_id: treatmentData.userId, // Use userId from input
      };

      const { data, error } = await supabase.from('treatments').insert(newTreatment).select().single();
      if (error) throw error;
      // setTreatments(prev => [...prev, data]); // Removed direct state update

      const patient = patients.find(p => p.id === treatmentData.patientId);
      if (patient) {
        await updatePatient(treatmentData.patientId, {
          hasOutstandingBalance: true,
          totalOutstanding: (patient.totalOutstanding || 0) + calculatedTotalCost, // Use calculatedTotalCost
        });
      }

      // Only add inventory transactions if medications exist
      if (treatmentData.medications && treatmentData.medications.length > 0) {
        for (const med of treatmentData.medications) {
          await addInventoryTransaction({
            inventoryItemId: med.inventoryItemId,
            type: 'deduction',
            quantity: med.quantity,
            reason: `Used for treatment (Patient ID: ${treatmentData.patientId})`,
            referenceId: data.id,
            referenceType: 'treatment',
            createdBy: treatmentData.userId
          });
        }
      }

      toast.success('Treatment recorded successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to add treatment');
      console.error(error);
    }
  };

  const updateTreatment = async (id: string, treatmentData: Partial<Treatment>) => {
    const updatedTreatmentData: any = { updated_at: new Date() };
    if (treatmentData.amountPaid !== undefined) updatedTreatmentData.amount_paid = toSafeNumber(treatmentData.amountPaid);
    if (treatmentData.paymentStatus !== undefined) updatedTreatmentData.payment_status = treatmentData.paymentStatus;
    if (treatmentData.totalCost !== undefined) updatedTreatmentData.total_cost = toSafeNumber(treatmentData.totalCost);
    if (treatmentData.dueDate !== undefined) updatedTreatmentData.due_date = treatmentData.dueDate;
    if (treatmentData.diagnosis !== undefined) updatedTreatmentData.diagnosis = treatmentData.diagnosis;
    if (treatmentData.notes !== undefined) updatedTreatmentData.notes = treatmentData.notes;
    if (treatmentData.medications !== undefined) updatedTreatmentData.medications = treatmentData.medications;
    if (treatmentData.services !== undefined) updatedTreatmentData.services = treatmentData.services;
    if (treatmentData.date !== undefined) updatedTreatmentData.date = treatmentData.date;
    if (treatmentData.patientId !== undefined) updatedTreatmentData.patient_id = treatmentData.patientId;

    try {
      const { error } = await supabase
        .from('treatments')
        .update(updatedTreatmentData)
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      // setTreatments(prev => prev.map(t => (t.id === id ? data : t))); // Removed direct state update
      toast.success('Treatment updated successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to update treatment');
      console.error(error);
    }
  };

  // INVENTORY ITEM ACTIONS
  const addInventoryItem = async (
    itemData: Omit<InventoryItem, 'id' | 'createdAt' | 'updatedAt'>
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add inventory item.');
        return;
      }
      const newItem = {
        name: itemData.name,
        category: itemData.category,
        supplier: itemData.supplier || null, // Ensure null for optional string
        current_stock: toSafeNumber(itemData.currentStock),
        unit: itemData.unit,
        unit_cost: toSafeNumber(itemData.unitCost),
        reorder_level: toSafeNumber(itemData.reorderLevel),
        reorder_quantity: toSafeNumber(itemData.reorderQuantity),
        notes: itemData.notes || null, // Ensure null for optional string
        created_at: new Date(),
        updated_at: new Date(),
        user_id: user.id,
      };

      const { error } = await supabase.from('inventory_items').insert(newItem).select().single();
      if (error) throw error;
      // setInventoryItems(prev => [...prev, data]); // Removed direct state update
      toast.success('Inventory item added');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to add inventory item');
      console.error(error);
    }
  };

  const updateInventoryItem = async (id: string, itemData: Partial<InventoryItem>) => {
    const updatedItemData: any = { updated_at: new Date() };
    if (itemData.name !== undefined) updatedItemData.name = itemData.name;
    if (itemData.category !== undefined) updatedItemData.category = itemData.category;
    if (itemData.supplier !== undefined) updatedItemData.supplier = itemData.supplier === '' ? null : itemData.supplier; // Convert empty string to null
    if (itemData.currentStock !== undefined) updatedItemData.current_stock = toSafeNumber(itemData.currentStock);
    if (itemData.unit !== undefined) updatedItemData.unit = itemData.unit;
    if (itemData.unitCost !== undefined) updatedItemData.unit_cost = toSafeNumber(itemData.unitCost);
    if (itemData.reorderLevel !== undefined) updatedItemData.reorder_level = toSafeNumber(itemData.reorderLevel);
    if (itemData.reorderQuantity !== undefined) updatedItemData.reorder_quantity = toSafeNumber(itemData.reorderQuantity);
    if (itemData.notes !== undefined) updatedItemData.notes = itemData.notes === '' ? null : itemData.notes; // Convert empty string to null

    try {
      const { error } = await supabase
        .from('inventory_items')
        .update(updatedItemData)
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      // setInventoryItems(prev => prev.map(i => (i.id === id ? data : i))); // Removed direct state update
      toast.success('Inventory item updated');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to update inventory item');
      console.error(error);
    }
  };

  const deleteInventoryItem = async (id: string) => {
    try {
      const { error } = await supabase.from('inventory_items').delete().eq('id', id);
      if (error) throw error;
      // setInventoryItems(prev => prev.filter(i => i.id !== id)); // Removed direct state update
      toast.success('Inventory item deleted');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to delete inventory item');
      console.error(error);
    }
  };

  // INVENTORY TRANSACTION ACTION
  const addInventoryTransaction = async (
    transactionData: Omit<InventoryTransaction, 'id' | 'createdAt' | 'balance'>
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add inventory transaction.');
        return;
      }
      const item = inventoryItems.find(i => i.id === transactionData.inventoryItemId);
      if (!item) {
        toast.error('Inventory item not found');
        return;
      }
      let newBalance = item.currentStock;
      if (transactionData.type === 'addition') {
        newBalance += transactionData.quantity;
      } else if (transactionData.type === 'deduction') {
        newBalance -= transactionData.quantity;
      }

      const newTransaction: SupabaseInventoryTransactionInsert = { // Explicitly type it here
        inventory_item_id: transactionData.inventoryItemId,
        type: transactionData.type,
        quantity: transactionData.quantity,
        balance: newBalance, // 'balance' is calculated here
        reason: transactionData.reason,
        reference_id: transactionData.referenceId || null, // Ensure it's string or null
        reference_type: transactionData.referenceType || 'manual', // Default to manual if not provided
        created_by: transactionData.createdBy,
        created_at: new Date(),
      };
      const { error } = await supabase.from('inventory_transactions').insert(newTransaction).select().single();
      if (error) throw error;

      await updateInventoryItem(item.id, { currentStock: newBalance });

      // setInventoryTransactions(prev => [...prev, data]); // Removed direct state update
      toast.success('Inventory transaction recorded');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to add inventory transaction');
      console.error(error);
    }
  };

  // PAYMENT ACTIONS
  const addPayment = async (
    paymentData: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add payment.');
        return;
      }
      const newPayment = {
        created_at: new Date(),
        updated_at: new Date(),
        patient_id: paymentData.patientId,
        treatment_id: paymentData.treatmentId,
        amount: paymentData.amount,
        payment_date: paymentData.paymentDate,
        method: paymentData.method,
        status: paymentData.status,
        notes: paymentData.notes,
        user_id: user.id,
      };

      const { error } = await supabase.from('payments').insert(newPayment).select().single();
      if (error) throw error;
      // setPayments(prev => [...prev, data]); // Removed direct state update

      const treatment = treatments.find(t => t.id === paymentData.treatmentId);
      if (treatment) {
        const updatedAmountPaid = toSafeNumber(treatment.amountPaid) + toSafeNumber(paymentData.amount);
        const updatedStatus = updatedAmountPaid >= toSafeNumber(treatment.totalCost) ? 'paid' : 'partial';
        await updateTreatment(treatment.id, { amountPaid: updatedAmountPaid, paymentStatus: updatedStatus });

        const patient = patients.find(p => p.id === treatment.patientId);
        if (patient) {
          const newOutstanding = toSafeNumber(patient.totalOutstanding) - toSafeNumber(paymentData.amount);
          await updatePatient(patient.id, {
            totalOutstanding: newOutstanding < 0 ? 0 : newOutstanding,
            hasOutstandingBalance: newOutstanding > 0,
          });
        }
      }

      toast.success('Payment recorded');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error) {
      toast.error('Failed to add payment');
      console.error(error);
    }
  };

  const updatePaymentSettings = async (settingsData: Partial<PaymentSettings>) => {
    try {
      if (!user) {
        toast.error('Authentication required to update settings.');
        return;
      }

      const { data, error } = await supabase
        .from('payment_settings')
        .upsert({
          user_id: user.id, // Ensure settings are linked to user
          grace_period: settingsData.gracePeriod,
          reminder_intervals: settingsData.reminderIntervals,
          auto_notify: settingsData.autoNotify,
          updated_at: new Date().toISOString(),
        }, {
          onConflict: 'user_id', // Upsert based on user_id
        })
        .select()
        .single();

      if (error) throw error;

      setPaymentSettings({
        gracePeriod: data.grace_period,
        reminderIntervals: data.reminder_intervals,
        autoNotify: data.auto_notify,
      });
      toast.success('Payment settings updated');
    } catch (error) {
      toast.error('Failed to update payment settings');
      console.error(error);
    }
  };

  const updateClinicSettings = async (settingsData: Partial<ClinicSettings>) => {
    try {
      if (!user) {
        toast.error('Authentication required to update clinic settings.');
        return;
      }

      const { data, error } = await supabase
        .from('clinic_settings')
        .upsert({
          user_id: user.id, // Ensure settings are linked to user
          clinic_name: settingsData.clinicName,
          address: settingsData.address,
          phone: settingsData.phone,
          email: settingsData.email,
          logo_url: settingsData.logoUrl,
          updated_at: new Date().toISOString(),
        }, {
          onConflict: 'user_id', // Upsert based on user_id
        })
        .select()
        .single();

      if (error) throw error;

      setClinicSettings({
        id: data.id,
        clinicName: data.clinic_name,
        address: data.address,
        phone: data.phone,
        email: data.email,
        logoUrl: data.logo_url,
        createdAt: data.created_at ? new Date(data.created_at) : new Date(),
        updatedAt: data.updated_at ? new Date(data.updated_at) : new Date(),
      });
      toast.success('Clinic settings updated');
    } catch (error) {
      toast.error('Failed to update clinic settings');
      console.error(error);
    }
  };

  const updateInventorySettings = async (settingsData: Partial<InventorySettings>) => {
    try {
      if (!user) {
        toast.error('Authentication required to update inventory settings.');
        return;
      }

      const { data, error } = await supabase
        .from('inventory_settings')
        .upsert({
          user_id: user.id, // Ensure settings are linked to user
          low_stock_threshold: settingsData.lowStockThreshold,
          enable_auto_reorder: settingsData.enableAutoReorder,
          auto_reorder_threshold: settingsData.autoReorderThreshold,
          updated_at: new Date().toISOString(),
        }, {
          onConflict: 'user_id', // Upsert based on user_id
        })
        .select()
        .single();

      if (error) throw error;

      setInventorySettings({
        id: data.id,
        lowStockThreshold: data.low_stock_threshold,
        enableAutoReorder: data.enable_auto_reorder,
        autoReorderThreshold: data.auto_reorder_threshold,
        createdAt: data.created_at ? new Date(data.created_at) : new Date(),
        updatedAt: data.updated_at ? new Date(data.updated_at) : new Date(),
      });
      toast.success('Inventory settings updated');
    } catch (error) {
      toast.error('Failed to update inventory settings');
      console.error(error);
    }
  };

  const markAlertAsRead = async (id: string, type: 'stock' | 'payment') => {
    try {
      if (!user) {
        toast.error('Authentication required to mark alerts as read.');
        return;
      }

      if (type === 'stock') {
        const { error } = await supabase
          .from('stock_alerts')
          .update({ is_read: true })
          .eq('id', id)
          .eq('user_id', user.id); // Ensure user owns the record
        if (error) throw error;
        setStockAlerts(prev => prev.map(alert => alert.id === id ? { ...alert, isRead: true } : alert));
      } else if (type === 'payment') {
        const { error } = await supabase
          .from('payment_alerts')
          .update({ is_read: true })
          .eq('id', id)
          .eq('user_id', user.id); // Ensure user owns the record
        if (error) throw error;
        setPaymentAlerts(prev => prev.map(alert => alert.id === id ? { ...alert, isRead: true } : alert));
      }
      toast.success('Alert marked as read');
    } catch (error) {
      toast.error('Failed to mark alert as read');
      console.error(error);
    }
  };


  const contextValue: AppContextType = {
    patients,
    treatments,
    inventoryItems,
    inventoryTransactions,
    stockAlerts,
    payments,
    paymentAlerts,
    paymentSettings,
    clinicSettings,
    inventorySettings,
    user,
    session,
    authLoading,
    addPatient,
    updatePatient,
    deletePatient,
    addTreatment,
    updateTreatment,
    addInventoryItem,
    updateInventoryItem,
    deleteInventoryItem,
    addInventoryTransaction,
    addPayment,
    updatePaymentSettings,
    updateClinicSettings,
    updateInventorySettings,
    markAlertAsRead,
  };

  return (
    <AppContext.Provider value={contextValue}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};
