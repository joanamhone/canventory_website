import React, { createContext, useContext, useState, ReactNode, useEffect, useCallback } from 'react';
import { Patient, Treatment, TreatmentMedication, TreatmentService, SupabaseTreatment } from '../types/patient';
import { InventoryItem, InventoryTransaction, StockAlert, InventoryTransactionType, InventoryReferenceType, InventoryItemCategory, StockAlertType } from '../types/inventory';
import { Payment, PaymentAlert, PaymentSettings, PaymentMethod, PaymentStatus } from '../types/payment'; // Import PaymentMethod and PaymentStatus
import { ClinicSettings, InventorySettings } from '../types/settings';
import toast from 'react-hot-toast';
import { addDays, isPast } from 'date-fns';
import { supabase } from '../lib/supabaseClient';
import { User, Session, AuthChangeEvent } from '@supabase/supabase-js';

// Define Supabase specific types for raw data fetched from DB (snake_case)
interface SupabaseInventoryItem {
  id: string;
  name: string;
  category: string;
  supplier: string | null;
  current_stock: number;
  unit: string;
  unit_cost: number;
  reorder_level: number;
  reorder_quantity: number;
  notes: string | null;
  created_at: string;
  updated_at: string;
  user_id: string;
}

interface SupabaseInventoryTransaction {
  id: string;
  inventory_item_id: string;
  type: string; // Corresponds to InventoryTransactionType
  quantity: number;
  balance: number;
  reason: string;
  reference_id: string | null;
  reference_type: string; // Corresponds to InventoryReferenceType
  created_by: string;
  created_at: string;
}

interface SupabaseStockAlert {
  id: string;
  inventory_item_id: string;
  type: string; // Corresponds to StockAlertType
  message: string;
  is_read: boolean;
  created_at: string;
}

interface SupabasePayment {
  id: string;
  treatment_id: string;
  patient_id: string;
  amount: number;
  payment_date: string;
  method: string;
  status: string;
  notes: string | null;
  created_at: string;
  updated_at: string;
}

// Updated PaymentSettings interface to include 'id' for internal state management
interface PaymentSettingsWithId extends PaymentSettings {
  id: string;
}

interface SupabasePaymentSettings {
  id: string;
  grace_period: number;
  reminder_intervals: number[];
  auto_notify: boolean;
}

interface SupabaseClinicSettings {
  id: string;
  clinic_name: string;
  address: string | null;
  phone: string | null;
  email: string | null;
  created_at: string;
  updated_at: string;
}

interface SupabaseInventorySettings {
  id: string;
  low_stock_threshold: number;
  enable_auto_reorder: boolean;
  auto_reorder_threshold: number;
  created_at: string;
  updated_at: string;
}


interface AppContextType {
  // Existing states
  patients: Patient[];
  treatments: Treatment[];
  inventoryItems: InventoryItem[];
  inventoryTransactions: InventoryTransaction[];
  stockAlerts: StockAlert[];
  payments: Payment[];
  paymentAlerts: PaymentAlert[];
  paymentSettings: PaymentSettingsWithId; // Use the updated interface
  clinicSettings: ClinicSettings | null;
  inventorySettings: InventorySettings;

  // New auth states
  user: User | null;
  session: Session | null;
  authLoading: boolean;

  // Existing actions
  // userId is now REQUIRED as input for addPatient
  addPatient: (patient: Omit<Patient, 'id' | 'createdAt' | 'updatedAt' | 'hasOutstandingBalance' | 'totalOutstanding'> & { userId: string }) => Promise<void>;
  updatePatient: (id: string, patientData: Partial<Patient>) => Promise<void>;
  deletePatient: (id: string) => Promise<void>;

  // userId is now REQUIRED as input for addTreatment
  // totalCost is now omitted as it's calculated internally
  addTreatment: (treatment: Omit<Treatment, 'id' | 'createdAt' | 'updatedAt' | 'amountPaid' | 'paymentStatus' | 'totalCost'> & { userId: string }) => Promise<void>;
  updateTreatment: (id: string, treatmentData: Partial<Treatment>) => Promise<void>;

  addInventoryItem: (item: Omit<InventoryItem, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
  updateInventoryItem: (id: string, itemData: Partial<InventoryItem>) => Promise<void>;
  deleteInventoryItem: (id: string) => Promise<void>;

  // 'balance' is calculated internally, 'id' and 'createdAt' are generated by Supabase.
  // 'createdBy' is expected as an input.
  // Explicitly allow referenceId to be string | null to match the type definition
  addInventoryTransaction: (transaction: Omit<InventoryTransaction, 'id' | 'createdAt' | 'balance'>) => Promise<void>;

  addPayment: (payment: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
  updatePaymentSettings: (settings: Partial<PaymentSettings>) => Promise<void>;
  updateClinicSettings: (settings: Partial<ClinicSettings>) => Promise<void>;
  updateInventorySettings: (settings: Partial<InventorySettings>) => Promise<void>;

  markAlertAsRead: (id: string, type: 'stock' | 'payment') => Promise<void>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

// Define a type for the object to be inserted into inventory_transactions table
// This type includes 'balance' and 'created_at' which are generated/calculated within the function
// It uses snake_case for Supabase column names
interface SupabaseInventoryTransactionInsert {
  inventory_item_id: string;
  type: InventoryTransactionType;
  quantity: number;
  balance: number;
  reason: string;
  reference_id: string | null; // Matches Supabase column type
  reference_type: InventoryReferenceType;
  created_by: string;
  created_at: Date;
}

export const AppProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // States for data
  const [patients, setPatients] = useState<Patient[]>([]);
  const [treatments, setTreatments] = useState<Treatment[]>([]);
  const [inventoryItems, setInventoryItems] = useState<InventoryItem[]>([]);
  const [inventoryTransactions, setInventoryTransactions] = useState<InventoryTransaction[]>([]);
  const [stockAlerts, setStockAlerts] = useState<StockAlert[]>([]);
  const [payments, setPayments] = useState<Payment[]>([]);
  const [paymentAlerts, setPaymentAlerts] = useState<PaymentAlert[]>([]);
  // Initialize paymentSettings with an id
  const [paymentSettings, setPaymentSettings] = useState<PaymentSettingsWithId>({
    id: '1', // Default ID for settings
    gracePeriod: 30,
    reminderIntervals: [7, 14, 30],
    autoNotify: true,
  });
  const [clinicSettings, setClinicSettings] = useState<ClinicSettings | null>(null);
  const [inventorySettings, setInventorySettings] = useState<InventorySettings>({
    id: '1',
    lowStockThreshold: 20,
    enableAutoReorder: false,
    autoReorderThreshold: 10,
    createdAt: new Date(),
    updatedAt: new Date(),
  });

  // New states for authentication
  const [user, setUser] = useState<User | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [authLoading, setAuthLoading] = useState(true);

  // State to track if the initial data load error has been toasted
  const [hasToastedInitialLoadError, setHasToastedInitialLoadError] = useState(false);


  // Helper function for robust number conversion
  const toSafeNumber = (value: any): number => {
    const num = Number(value);
    return isNaN(num) ? 0 : num;
  };

  // --- Auth State Management ---
  useEffect(() => {
    setAuthLoading(true);

    supabase.auth.getSession().then(({ data: { session } }: { data: { session: Session | null } }) => {
      setSession(session);
      setUser(session?.user || null);
      setAuthLoading(false);
    }).catch((error: unknown) => { // Explicitly type error as unknown
      console.error("Error getting session:", error);
      setAuthLoading(false);
    });

    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event: AuthChangeEvent, session: Session | null) => { // Explicitly type _event and session
        setSession(session);
        setUser(session?.user || null);
        if (_event === 'INITIAL_SESSION' || _event === 'SIGNED_IN' || _event === 'SIGNED_OUT') {
          setAuthLoading(false);
        }
        console.log("Auth State Changed:", _event, session?.user?.id);
      }
    );

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  // --- Data Fetching Logic (Memoized with useCallback) ---
  const fetchData = useCallback(async () => {
    if (authLoading || !user || !session) {
      // Clear data if not authenticated or loading
      setPatients([]);
      setTreatments([]);
      setInventoryItems([]);
      setInventoryTransactions([]);
      setStockAlerts([]);
      setPayments([]);
      setPaymentAlerts([]);
      setPaymentSettings({
        id: '1', // Ensure ID is set when clearing
        gracePeriod: 30,
        reminderIntervals: [7, 14, 30],
        autoNotify: true,
      });
      setClinicSettings(null);
      setInventorySettings({
        id: '1',
        lowStockThreshold: 20,
        enableAutoReorder: false,
        autoReorderThreshold: 10,
        createdAt: new Date(),
        updatedAt: new Date(),
      });
      return;
    }

    try {
      // Patients
      const { data: patientsData, error: patientsError } = await supabase
        .from<'patients', Patient>('patients')
        .select('*');
      if (patientsError) throw patientsError;
      setPatients(patientsData || []);

      // Treatments
      const { data: rawTreatmentsData, error: treatmentsError } = await supabase
        .from('treatments')
        .select('*');
      if (treatmentsError) throw treatmentsError;
      
      // NEW DEBUG LOG: Raw data from Supabase before conversion
      console.log('Raw Treatments Data from Supabase:', rawTreatmentsData);

      const parsedTreatmentsData: Treatment[] = rawTreatmentsData?.map((t: SupabaseTreatment) => {
        // Parse medications and services if they are strings
        const medicationsArray = typeof t.medications === 'string' ? JSON.parse(t.medications) : t.medications;
        const servicesArray = typeof t.services === 'string' ? JSON.parse(t.services) : t.services;

        return {
          id: t.id,
          patientId: t.patient_id,
          diagnosis: t.diagnosis,
          notes: t.notes || undefined,
          medications: (Array.isArray(medicationsArray) ? medicationsArray : []).map((med: TreatmentMedication) => ({ // Explicitly type med
            id: med.id,
            inventoryItemId: med.inventoryItemId,
            name: med.name,
            quantity: toSafeNumber(med.quantity),
            dosage: med.dosage,
            unitCost: toSafeNumber(med.unitCost),
            totalCost: toSafeNumber(med.totalCost),
          })) as TreatmentMedication[],
          services: (Array.isArray(servicesArray) ? servicesArray : []).map((service: TreatmentService) => ({ // Explicitly type service
            id: service.id,
            name: service.name,
            description: service.description,
            cost: toSafeNumber(service.cost),
          })) as TreatmentService[],
          date: t.date ? new Date(t.date) : new Date(),
          totalCost: toSafeNumber(t.total_cost),
          amountPaid: toSafeNumber(t.amount_paid),
          paymentStatus: t.payment_status,
          dueDate: t.due_date ? new Date(t.due_date) : undefined,
          createdAt: t.created_at ? new Date(t.created_at) : new Date(),
          updatedAt: t.updated_at ? new Date(t.updated_at) : new Date(),
          userId: t.user_id,
        };
      }) || [];

      // ADDED DEBUG LOG HERE
      console.log('Fetched Treatments (after conversion):', parsedTreatmentsData); 

      setTreatments(parsedTreatmentsData);

      // Inventory Items
      const { data: inventoryData, error: inventoryError } = await supabase
        .from<'inventory_items', SupabaseInventoryItem>('inventory_items') // Use SupabaseInventoryItem
        .select('*');
      if (inventoryError) throw inventoryError;

     const parsedInventoryData = inventoryData?.map((item: SupabaseInventoryItem) => ({ // Explicitly type item
          id: item.id,
          name: item.name,
          category: item.category as InventoryItemCategory,
          type: item.category, 
          supplier: item.supplier,
          currentStock: toSafeNumber(item.current_stock),
          unit: item.unit,
          unitCost: toSafeNumber(item.unit_cost),
          reorderLevel: toSafeNumber(item.reorder_level),
          reorderQuantity: toSafeNumber(item.reorder_quantity),
          notes: item.notes,
          createdAt: item.created_at ? new Date(item.created_at) : new Date(),
          updatedAt: item.updated_at ? new Date(item.updated_at) : new Date(),
        })) || [];

      setInventoryItems(parsedInventoryData);

      // Inventory Transactions
      const { data: transactionsData, error: transactionsError } = await supabase
        .from<'inventory_transactions', SupabaseInventoryTransaction>('inventory_transactions') // Use SupabaseInventoryTransaction
        .select('*');
      if (transactionsError) throw transactionsError;
      const parsedTransactionsData = transactionsData?.map((transaction: SupabaseInventoryTransaction) => ({ // Explicitly type transaction
        id: transaction.id,
        inventoryItemId: transaction.inventory_item_id,
        type: transaction.type as InventoryTransactionType,
        quantity: transaction.quantity,
        balance: transaction.balance,
        reason: transaction.reason,
        referenceId: transaction.reference_id,
        referenceType: transaction.reference_type as InventoryReferenceType,
        createdBy: transaction.created_by,
        createdAt: transaction.created_at ? new Date(transaction.created_at) : new Date(),
      })) || [];
      setInventoryTransactions(parsedTransactionsData);

      // Stock Alerts
      const { data: stockAlertsData, error: stockAlertsError } = await supabase
        .from<'stock_alerts', SupabaseStockAlert>('stock_alerts') // Use SupabaseStockAlert
        .select('*');
      if (stockAlertsError) throw stockAlertsError;
      const parsedStockAlertsData: StockAlert[] = stockAlertsData?.map((alert: SupabaseStockAlert) => ({ // Explicitly type alert and cast 'type'
        id: alert.id,
        inventoryItemId: alert.inventory_item_id,
        type: alert.type as StockAlertType, // Cast 'type' to StockAlertType
        message: alert.message,
        isRead: alert.is_read,
        createdAt: alert.created_at ? new Date(alert.created_at) : new Date(),
      })) || [];
      setStockAlerts(parsedStockAlertsData);

      // Payments
      const { data: paymentsData, error: paymentsError } = await supabase
        .from<'payments', SupabasePayment>('payments') // Use SupabasePayment
        .select('*');
      if (paymentsError) throw paymentsError;
      const parsedPaymentsData: Payment[] = paymentsData?.map((payment: SupabasePayment) => ({ // Explicitly type payment and cast 'method'
        id: payment.id,
        treatmentId: payment.treatment_id,
        patientId: payment.patient_id,
        amount: payment.amount,
        paymentDate: payment.payment_date ? new Date(payment.payment_date) : new Date(),
        method: payment.method as PaymentMethod, // Cast 'method' to PaymentMethod
        status: payment.status as PaymentStatus, // Cast 'status' to PaymentStatus
        notes: payment.notes,
        createdAt: payment.created_at ? new Date(payment.created_at) : new Date(),
        updatedAt: payment.updated_at ? new Date(payment.updated_at) : new Date(),
      })) || [];
      setPayments(parsedPaymentsData);

      // Payment Settings (assume single row settings)
      const { data: paymentSettingsData, error: paymentSettingsError } = await supabase
        .from<'payment_settings', SupabasePaymentSettings>('payment_settings') // Use SupabasePaymentSettings
        .select('*')
        .limit(1)
        .single();
      if (!paymentSettingsError && paymentSettingsData) {
        setPaymentSettings({
          id: paymentSettingsData.id, // Assign the ID from fetched data
          gracePeriod: paymentSettingsData.grace_period,
          reminderIntervals: paymentSettingsData.reminder_intervals,
          autoNotify: paymentSettingsData.auto_notify,
        });
      }


      // Inventory Settings (assume single row settings)
      const { data: inventorySettingsData, error: inventorySettingsError } = await supabase
        .from<'inventory_settings', SupabaseInventorySettings>('inventory_settings') // Use SupabaseInventorySettings
        .select('*')
        .limit(1)
        .single();
      if (!inventorySettingsError && inventorySettingsData) {
        setInventorySettings({
          id: inventorySettingsData.id,
          lowStockThreshold: inventorySettingsData.low_stock_threshold,
          enableAutoReorder: inventorySettingsData.enable_auto_reorder,
          autoReorderThreshold: inventorySettingsData.auto_reorder_threshold,
          createdAt: inventorySettingsData.created_at ? new Date(inventorySettingsData.created_at) : new Date(),
          updatedAt: inventorySettingsData.updated_at ? new Date(inventorySettingsData.updated_at) : new Date(),
        });
      }
      // If data loaded successfully, reset the error toast flag
      setHasToastedInitialLoadError(false);
    } catch (error: unknown) { // Explicitly type error as unknown
      // Only toast if we haven't already toasted this error in the current session
      if (!hasToastedInitialLoadError) {
        toast.error('Failed to load data from database');
        setHasToastedInitialLoadError(true);
      }
      console.error(error);
    }
  }, [user, session, authLoading, hasToastedInitialLoadError]); // Added hasToastedInitialLoadError to dependencies

  // --- Trigger Data Fetching when Auth State Changes ---
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Function to check overdue payments & add alerts to DB if missing
  useEffect(() => {
    async function checkOverduePayments() {
      if (!user || !session || treatments.length === 0 || authLoading) {
        return;
      }
      for (const treatment of treatments) {
        if (treatment.paymentStatus !== 'paid' && treatment.dueDate) {
          const isOverdue = isPast(new Date(treatment.dueDate));
          if (isOverdue) {
            const existingAlert = paymentAlerts.find(
              alert => alert.treatmentId === treatment.id && !alert.isRead
            );
            if (!existingAlert) {
              const newAlert = {
                patient_id: treatment.patientId,
                treatment_id: treatment.id,
                due_amount: treatment.totalCost - treatment.amountPaid,
                due_date: treatment.dueDate,
                status: 'overdue',
                is_read: false,
                created_at: new Date(),
              };
              const { data, error } = await supabase.from('payment_alerts').insert(newAlert).select().single();
              if (error) {
                console.error('Failed to add payment alert:', error);
              } else if (data) {
                const addedAlert: PaymentAlert = {
                  id: data.id,
                  patientId: data.patient_id,
                  treatmentId: data.treatment_id,
                  dueAmount: data.due_amount,
                  dueDate: data.due_date ? new Date(data.due_date) : new Date(),
                  status: data.status,
                  isRead: data.is_read,
                  createdAt: data.created_at ? new Date(data.created_at) : new Date(),
                };
                setPaymentAlerts(prev => [...prev, addedAlert]);
                const patient = patients.find(p => p.id === treatment.patientId);
                if (patient) {
                  toast.error(`Payment overdue for patient: ${patient.name}`, {
                    duration: 5000,
                    position: 'top-right',
                  });
                }
              }
            }
          }
        }
      }
    }

    if (user && session && treatments.length > 0 && !authLoading) {
      checkOverduePayments();
      const interval = setInterval(checkOverduePayments, 24 * 60 * 60 * 1000);
      return () => clearInterval(interval);
    }
  }, [treatments, paymentAlerts, patients, paymentSettings.gracePeriod, user, session, authLoading]);

  // Check low stock alerts and add to DB if missing
  useEffect(() => {
    async function checkLowStock() {
      if (!user || !session || inventoryItems.length === 0 || authLoading) {
        return;
      }
      for (const item of inventoryItems) {
        if (item.currentStock <= item.reorderLevel) {
          // Check directly in the database for an existing UNREAD alert for this item
          const { data: dbExistingAlerts, error: dbCheckError } = await supabase
            .from('stock_alerts')
            .select('*')
            .eq('inventory_item_id', item.id)
            .eq('type', 'low')
            .eq('is_read', false) // Crucial: only consider unread alerts
            .limit(1);

          if (dbCheckError) {
            console.error('Error checking for existing stock alert in DB:', dbCheckError);
            continue; // Skip to next item to avoid infinite loop on DB error
          }

          // If no existing unread alert is found in the database
          if (!dbExistingAlerts || dbExistingAlerts.length === 0) {
            const newAlert = {
              inventory_item_id: item.id,
              type: 'low',
              message: `${item.name} is low in stock (${item.currentStock} ${item.unit} remaining)`,
              is_read: false,
              created_at: new Date(),
            };
            const { data, error } = await supabase.from('stock_alerts').insert(newAlert).select().single();
            if (error) {
              console.error('Failed to add stock alert:', error);
            } else if (data) {
              const addedAlert: StockAlert = {
                id: data.id,
                inventoryItemId: data.inventory_item_id,
                type: data.type as StockAlertType, // Ensure type is correctly cast
                message: data.message,
                isRead: data.is_read,
                createdAt: data.created_at ? new Date(data.created_at) : new Date(),
              };
              setStockAlerts(prev => [...prev, addedAlert]);
              toast.error(`Low stock alert: ${item.name}`, {
                duration: 5000,
                position: 'top-right',
              });
            }
          }
        }
      }
    }

    if (user && session && inventoryItems.length > 0 && !authLoading) {
      checkLowStock();
    }
  }, [inventoryItems, stockAlerts, user, session, authLoading]);

  // PATIENT ACTIONS
  const addPatient = async (
    patientData: Omit<Patient, 'id' | 'createdAt' | 'updatedAt' | 'hasOutstandingBalance' | 'totalOutstanding'> & { userId: string }
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add patient.');
        return;
      }
      const newPatient = {
        name: patientData.name,
        age: patientData.age,
        gender: patientData.gender,
        residence: patientData.residence,
        phone: patientData.phone || null, // Ensure null for optional string
        email: patientData.email || null, // Ensure null for optional string
        address: patientData.address || null, // Ensure null for optional string
        has_outstanding_balance: false, // This is correct (snake_case)
        total_outstanding: 0,           // This is correct (snake_case)
        created_at: new Date(),
        updated_at: new Date(),
        user_id: user.id,
      };
      const { error } = await supabase.from('patients').insert([newPatient]).select().single();
      if (error) throw error;
      // setPatients(prev => [...prev, data]); // Removed direct state update
      toast.success(`Patient ${patientData.name} added successfully`);
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to add patient');
      console.error(error);
    }
  };

  const updatePatient = async (id: string, patientData: Partial<Patient>) => {
    const updatedPatientData: any = { updated_at: new Date() };
    if (patientData.hasOutstandingBalance !== undefined) updatedPatientData.has_outstanding_balance = patientData.hasOutstandingBalance;
    if (patientData.totalOutstanding !== undefined) updatedPatientData.total_outstanding = patientData.totalOutstanding;
    if (patientData.name !== undefined) updatedPatientData.name = patientData.name;
    if (patientData.email !== undefined) updatedPatientData.email = patientData.email;
    if (patientData.phone !== undefined) updatedPatientData.phone = patientData.phone;
    if (patientData.address !== undefined) updatedPatientData.address = patientData.address;

    try {
      const { error } = await supabase
        .from('patients')
        .update(updatedPatientData)
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      // setPatients(prev => prev.map(p => (p.id === id ? data : p))); // Removed direct state update
      toast.success('Patient updated successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to update patient');
      console.error(error);
    }
  };

  const deletePatient = async (id: string) => {
    try {
      const { error } = await supabase.from('patients').delete().eq('id', id);
      if (error) throw error;
      // setPatients(prev => prev.filter(p => p.id !== id)); // Removed direct state update
      toast.success('Patient deleted successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to delete patient');
      console.error(error);
    }
  }
  // TREATMENT ACTIONS
  const addTreatment = async (
    treatmentData: Omit<Treatment, 'id' | 'createdAt' | 'updatedAt' | 'amountPaid' | 'paymentStatus' | 'totalCost'> & { userId: string }
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add treatment.');
        return;
      }

      // Calculate totalCost dynamically based on medications and services
      const calculatedTotalCost =
        (treatmentData.medications?.reduce((sum: number, med: TreatmentMedication) => sum + (med.totalCost ?? 0), 0) || 0) + // Explicitly type sum and med
        (treatmentData.services?.reduce((sum: number, service: TreatmentService) => sum + (service.cost ?? 0), 0) || 0); // Explicitly type sum and service

      const newTreatment = {
        diagnosis: treatmentData.diagnosis,
        notes: treatmentData.notes,
        medications: treatmentData.medications, // medications is already an array of TreatmentMedication
        services: treatmentData.services,     // services is already an array of TreatmentService
        date: treatmentData.date,
        total_cost: calculatedTotalCost, // Use the dynamically calculated totalCost
        amount_paid: 0,
        payment_status: 'pending' as const,
        due_date: addDays(new Date(), paymentSettings.gracePeriod),
        created_at: new Date(),
        updated_at: new Date(),
        patient_id: treatmentData.patientId,
        user_id: user.id, // Use userId from input
      };

      const { data, error } = await supabase.from('treatments').insert(newTreatment).select().single();
      if (error) throw error;
      // setTreatments(prev => [...prev, data]); // Removed direct state update

      const patient = patients.find(p => p.id === treatmentData.patientId);
      if (patient) {
        await updatePatient(treatmentData.patientId, {
          hasOutstandingBalance: true,
          totalOutstanding: (patient.totalOutstanding || 0) + calculatedTotalCost, // Use calculatedTotalCost
        });
      }

      // Only add inventory transactions if medications exist
      if (treatmentData.medications && treatmentData.medications.length > 0) {
        for (const med of treatmentData.medications) {
          await addInventoryTransaction({
            inventoryItemId: med.inventoryItemId,
            type: 'deduction',
            quantity: med.quantity,
            reason: `Used for treatment (Patient ID: ${treatmentData.patientId})`,
            referenceId: data.id,
            referenceType: 'treatment',
            createdBy: user.id
          });
        }
      }

      toast.success('Treatment recorded successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to add treatment');
      console.error(error);
    }
  };

  const updateTreatment = async (id: string, treatmentData: Partial<Treatment>) => {
    const updatedTreatmentData: any = { updated_at: new Date() };
    if (treatmentData.amountPaid !== undefined) updatedTreatmentData.amount_paid = toSafeNumber(treatmentData.amountPaid);
    if (treatmentData.paymentStatus !== undefined) updatedTreatmentData.payment_status = treatmentData.paymentStatus;
    if (treatmentData.totalCost !== undefined) updatedTreatmentData.total_cost = toSafeNumber(treatmentData.totalCost);
    if (treatmentData.dueDate !== undefined) updatedTreatmentData.due_date = treatmentData.dueDate;
    if (treatmentData.diagnosis !== undefined) updatedTreatmentData.diagnosis = treatmentData.diagnosis;
    if (treatmentData.notes !== undefined) updatedTreatmentData.notes = treatmentData.notes;
    if (treatmentData.medications !== undefined) updatedTreatmentData.medications = treatmentData.medications;
    if (treatmentData.services !== undefined) updatedTreatmentData.services = treatmentData.services;
    if (treatmentData.date !== undefined) updatedTreatmentData.date = treatmentData.date;
    if (treatmentData.patientId !== undefined) updatedTreatmentData.patient_id = treatmentData.patientId;

    try {
      const { error } = await supabase
        .from('treatments')
        .update(updatedTreatmentData)
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      // setTreatments(prev => prev.map(t => (t.id === id ? data : t))); // Removed direct state update
      toast.success('Treatment updated successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to update treatment');
      console.error(error);
    }
  };

  // INVENTORY ITEM ACTIONS
  const addInventoryItem = async (
    itemData: Omit<InventoryItem, 'id' | 'createdAt' | 'updatedAt'>
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add inventory item.');
        return;
      }
      const newItem = {
        name: itemData.name,
        category: itemData.category,
        supplier: itemData.supplier || null, // Ensure null for optional string
        current_stock: toSafeNumber(itemData.currentStock),
        unit: itemData.unit,
        unit_cost: toSafeNumber(itemData.unitCost),
        reorder_level: toSafeNumber(itemData.reorderLevel),
        reorder_quantity: toSafeNumber(itemData.reorderQuantity),
        notes: itemData.notes || null, // Ensure null for optional string
        created_at: new Date(),
        updated_at: new Date(),
        user_id: user.id,
      };

      const { error } = await supabase.from('inventory_items').insert(newItem).select().single();
      if (error) throw error;
      // setInventoryItems(prev => [...prev, data]); // Removed direct state update
      toast.success('Inventory item added');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to add inventory item');
      console.error(error);
    }
  };

  const updateInventoryItem = async (id: string, itemData: Partial<InventoryItem>) => {
    const updatedItemData: any = { updated_at: new Date() };
    if (itemData.name !== undefined) updatedItemData.name = itemData.name;
    if (itemData.category !== undefined) updatedItemData.category = itemData.category;
    if (itemData.supplier !== undefined) updatedItemData.supplier = itemData.supplier === '' ? null : itemData.supplier; // Convert empty string to null
    if (itemData.currentStock !== undefined) updatedItemData.current_stock = toSafeNumber(itemData.currentStock);
    if (itemData.unit !== undefined) updatedItemData.unit = itemData.unit;
    if (itemData.unitCost !== undefined) updatedItemData.unit_cost = toSafeNumber(itemData.unitCost);
    if (itemData.reorderLevel !== undefined) updatedItemData.reorder_level = toSafeNumber(itemData.reorderLevel);
    if (itemData.reorderQuantity !== undefined) updatedItemData.reorder_quantity = toSafeNumber(itemData.reorderQuantity);
    if (itemData.notes !== undefined) updatedItemData.notes = itemData.notes === '' ? null : itemData.notes; // Convert empty string to null

    try {
      const { error } = await supabase
        .from('inventory_items')
        .update(updatedItemData)
        .eq('id', id)
        .select()
        .single();
      if (error) throw error;
      // setInventoryItems(prev => prev.map(i => (i.id === id ? data : i))); // Removed direct state update
      toast.success('Inventory item updated');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to update inventory item');
      console.error(error);
    }
  };

  const deleteInventoryItem = async (id: string) => {
    try {
      const { error } = await supabase.from('inventory_items').delete().eq('id', id);
      if (error) throw error;
      // setInventoryItems(prev => prev.filter(i => i.id !== id)); // Removed direct state update
      toast.success('Inventory item deleted');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to delete inventory item');
      console.error(error);
    }
  };

  // INVENTORY TRANSACTION ACTION
  const addInventoryTransaction = async (
    transactionData: Omit<InventoryTransaction, 'id' | 'createdAt' | 'balance'>
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add inventory transaction.');
        return;
      }
      const item = inventoryItems.find(i => i.id === transactionData.inventoryItemId);
      if (!item) {
        toast.error('Inventory item not found');
        return;
      }
      let newBalance = item.currentStock;
      if (transactionData.type === 'addition') {
        newBalance += transactionData.quantity;
      } else if (transactionData.type === 'deduction') {
        newBalance -= transactionData.quantity;
      }

      const newTransaction: SupabaseInventoryTransactionInsert = { // Explicitly type it here
        inventory_item_id: transactionData.inventoryItemId,
        type: transactionData.type,
        quantity: transactionData.quantity,
        balance: newBalance, // 'balance' is calculated here
        reason: transactionData.reason,
        reference_id: transactionData.referenceId || null, // Ensure it's string or null
        reference_type: transactionData.referenceType || 'manual', // Default to manual if not provided
        created_by: transactionData.createdBy,
        created_at: new Date(),
      };
      const { error } = await supabase.from('inventory_transactions').insert(newTransaction).select().single();
      if (error) throw error;

      await updateInventoryItem(item.id, { currentStock: newBalance });

      // setInventoryTransactions(prev => [...prev, data]); // Removed direct state update
      toast.success('Inventory transaction recorded');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to add inventory transaction');
      console.error(error);
    }
  };

  // PAYMENT ACTIONS
  const addPayment = async (
    paymentData: Omit<Payment, 'id' | 'createdAt' | 'updatedAt'>
  ) => {
    try {
      if (!user) {
        toast.error('Authentication required to add payment.');
        return;
      }
      const newPayment = {
        created_at: new Date(),
        updated_at: new Date(),
        patient_id: paymentData.patientId,
        treatment_id: paymentData.treatmentId,
        amount: paymentData.amount,
        payment_date: paymentData.paymentDate,
        method: paymentData.method,
        status: paymentData.status,
        notes: paymentData.notes,
        user_id: user.id, // Add user ID here
      };

      const { error } = await supabase.from('payments').insert(newPayment).select().single();
      if (error) throw error;

      // Update the associated treatment's amountPaid and paymentStatus
      const relatedTreatment = treatments.find(t => t.id === paymentData.treatmentId);
      if (relatedTreatment) {
        const newAmountPaidForTreatment = relatedTreatment.amountPaid + paymentData.amount;
        const newPaymentStatusForTreatment = newAmountPaidForTreatment >= relatedTreatment.totalCost ? 'paid' : 'partial';

        await updateTreatment(relatedTreatment.id, {
          amountPaid: newAmountPaidForTreatment,
          paymentStatus: newPaymentStatusForTreatment,
        });

        // Update patient's totalOutstanding balance
        const patient = patients.find(p => p.id === paymentData.patientId);
        if (patient) {
          const newTotalOutstanding = (patient.totalOutstanding || 0) - paymentData.amount;
          await updatePatient(patient.id, {
            totalOutstanding: Math.max(0, newTotalOutstanding), // Ensure it doesn't go below zero
            hasOutstandingBalance: newTotalOutstanding > 0.01, // Check if still outstanding
          });
        }
      }

      toast.success('Payment recorded successfully');
      await fetchData(); // Re-fetch all data to ensure consistency
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to add payment');
      console.error(error);
    }
  };

  // SETTINGS ACTIONS
  const updatePaymentSettings = async (settings: Partial<PaymentSettings>) => {
    try {
      const { data, error } = await supabase
        .from('payment_settings')
        .update(settings as SupabasePaymentSettings) // Cast to Supabase type for update
        .eq('id', paymentSettings.id) // Use the ID from state
        .select()
        .single();
      if (error) throw error;
      setPaymentSettings(prev => ({ ...prev, ...data }));
      toast.success('Payment settings updated');
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to update payment settings');
      console.error(error);
    }
  };

  const updateClinicSettings = async (settings: Partial<ClinicSettings>) => {
    try {
      // Assuming clinic settings also has a fixed ID, e.g., '1'
      const { data, error } = await supabase
        .from('clinic_settings')
        .update(settings as SupabaseClinicSettings) // Cast to Supabase type for update
        .eq('id', clinicSettings?.id || '1') // Use existing ID or default to '1'
        .select()
        .single();

      if (error) throw error;
      setClinicSettings(data);
      toast.success('Clinic settings updated');
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to update clinic settings');
      console.error(error);
    }
  };

  const updateInventorySettings = async (settings: Partial<InventorySettings>) => {
    try {
      const { data, error } = await supabase
        .from('inventory_settings')
        .update(settings as SupabaseInventorySettings) // Cast to Supabase type for update
        .eq('id', inventorySettings.id) // Use the ID from state
        .select()
        .single();
      if (error) throw error;
      setInventorySettings(data);
      toast.success('Inventory settings updated');
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to update inventory settings');
      console.error(error);
    }
  };

  const markAlertAsRead = async (id: string, type: 'stock' | 'payment') => {
    try {
      if (type === 'stock') {
        const { error } = await supabase
          .from('stock_alerts')
          .update({ is_read: true, updated_at: new Date().toISOString() }) // Convert date to ISO string
          .eq('id', id);
        if (error) throw error;
        setStockAlerts(prev => prev.map(alert =>
          alert.id === id ? { ...alert, isRead: true } : alert
        ));
      } else if (type === 'payment') {
        const { error } = await supabase
          .from('payment_alerts')
          .update({ is_read: true, updated_at: new Date().toISOString() }) // Convert date to ISO string
          .eq('id', id);
        if (error) throw error;
        setPaymentAlerts(prev => prev.map(alert =>
          alert.id === id ? { ...alert, isRead: true } : alert
        ));
      }
      toast.success('Alert marked as read');
    } catch (error: unknown) { // Explicitly type error
      toast.error('Failed to mark alert as read');
      console.error(error);
    }
  };


  return (
    <AppContext.Provider
      value={{
        patients,
        treatments,
        inventoryItems,
        inventoryTransactions,
        stockAlerts,
        payments,
        paymentAlerts,
        paymentSettings,
        clinicSettings,
        inventorySettings,
        user,
        session,
        authLoading,
        addPatient,
        updatePatient,
        deletePatient,
        addTreatment,
        updateTreatment,
        addInventoryItem,
        updateInventoryItem,
        deleteInventoryItem,
        addInventoryTransaction,
        addPayment,
        updatePaymentSettings,
        updateClinicSettings,
        updateInventorySettings,
        markAlertAsRead,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useAppContext must be used within an AppProvider');
  }
  return context;
};
